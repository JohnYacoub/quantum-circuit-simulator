import React, { useEffect } from "react";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

const BlochSphere = ({ width, height }) => {
  useEffect(() => {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(23, width / height, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ alpha: true });
    const controls = new OrbitControls(camera, renderer.domElement);
    scene.background = null;

    renderer.setSize(width, height);
    camera.position.set(50, 30, 100);
    controls.update();

    document.getElementById("bloch").appendChild(renderer.domElement);
    // remove canvas border generated by three.js
    document.styleSheets[0].insertRule(
      "canvas { outline:none; border:none; overflow:visible }",
      0
    );

    const geometry = new THREE.SphereGeometry(15, 64, 64);
    // const vertexShader = `
    //   varying vec2 vUv;
    //   void main() {
    //     vUv = uv;
    //     gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
    //   }
    //     `;

    // const fragmentShader = `
    // varying vec2 vUv;
    // void main() {
    //   vec2 xy = sin(1.5 * vUv);
    //   gl_FragColor = vec4(xy, 1.0, 1.0);
    // }`;
    // const material = new THREE.ShaderMaterial({
    //   vertexShader,
    //   fragmentShader,
    // });
    const material = new THREE.MeshPhongMaterial({
      color: "lightblue",
      opacity: 0.2,
      transparent: true,
    });

    const blochSphere = new THREE.Mesh(geometry, material);
    scene.add(blochSphere);
    blochSphere.scale.set(1, 1, 1);

    function makeTextSprite(message, xPos, yPos, zPos) {
      const canvas = document.createElement("canvas");
      const context = canvas.getContext("2d");
      context.font = "40px Arial";
      context.strokeStyle = "rgba(255,255,255,1.0)";

      // text color
      context.fillStyle = "rgba(255, 255, 255, 1.0)";
      context.fillText(message, 120, 40); // WRITE TEXT
      // canvas contents will be used for a texture
      const texture = new THREE.Texture(canvas);
      texture.needsUpdate = true;

      const spriteMaterial = new THREE.SpriteMaterial({
        map: texture,
        useScreenCoordinates: false,
      });
      const sprite = new THREE.Sprite(spriteMaterial);

      sprite.position.set(xPos, yPos, zPos);
      sprite.scale.set(20, 10, 0.0);
      return sprite;
    }
    // axis labels
    const spriteZ = makeTextSprite("Z", 0, 19, 0);
    spriteZ.material.map.needsUpdate = true;
    scene.add(spriteZ);
    const spriteY = makeTextSprite("Y", 20, 0, 0);
    spriteY.material.map.needsUpdate = true;
    scene.add(spriteY);
    const spriteX = makeTextSprite("X", 0, 0, 20);
    spriteX.material.map.needsUpdate = true;
    scene.add(spriteX);

    //qubit |0> and |1> labels
    const spriteQubit0 = makeTextSprite("|0⟩", 5, 18, 0);
    spriteQubit0.material.map.needsUpdate = true;
    scene.add(spriteQubit0);
    const spriteQubit1 = makeTextSprite("|1⟩", 5, -21, 0);
    spriteQubit1.material.map.needsUpdate = true;
    scene.add(spriteQubit1);

    //arrows
    const sourcePosZ = new THREE.Vector3(0, 0, 0);
    const targetPosZ = new THREE.Vector3(0, 20, 0);
    const directionZ = new THREE.Vector3().sub(targetPosZ, sourcePosZ);
    const arrowHelperZ = new THREE.ArrowHelper(
      directionZ.clone().normalize(),
      sourcePosZ,
      directionZ.length(),
      0xb186f7,
      2,
      2
    );

    const sourcePosY = new THREE.Vector3(0, 0, 0);
    const targetPosY = new THREE.Vector3(20, 0, 0);
    const directionY = new THREE.Vector3().sub(targetPosY, sourcePosY);
    const arrowHelperY = new THREE.ArrowHelper(
      directionY.clone().normalize(),
      sourcePosY,
      directionY.length(),
      0xb186f7,
      2,
      2
    );

    const sourcePosX = new THREE.Vector3(0, 0, 0);
    const targetPosX = new THREE.Vector3(0, 0, 20);
    const directionX = new THREE.Vector3().sub(targetPosX, sourcePosY);
    const arrowHelperX = new THREE.ArrowHelper(
      directionX.clone().normalize(),
      sourcePosX,
      directionX.length(),
      0xb186f7,
      2,
      2
    );

    scene.add(arrowHelperY);
    scene.add(arrowHelperX);
    scene.add(arrowHelperZ);

    // Psi line
    const lineMaterial = new THREE.LineBasicMaterial({
      color: 0x1efbfb,
    });
    const points = [];
    points.push(new THREE.Vector3(0, 0, 0));
    points.push(new THREE.Vector3(10, 10, 5));
    const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(lineGeometry, lineMaterial);
    scene.add(line);

    // Psi point
    const pointGeometry = new THREE.SphereGeometry(0.5, 10, 10);
    const pointMaterial = new THREE.MeshBasicMaterial({ color: 0x1efbfb });
    const point3D = new THREE.Mesh(pointGeometry, pointMaterial);
    scene.add(point3D);
    point3D.position.set(10, 10, 5);

    //qubit |Ψ⟩ label
    const spritePsi = makeTextSprite("|Ψ⟩", 10, 10, 5);
    spritePsi.material.map.needsUpdate = true;
    scene.add(spritePsi);

    //add some lighting
    const ambientLight = new THREE.AmbientLight(0x0c0c0c);
    scene.add(ambientLight);

    const spotLight = new THREE.SpotLight(0xffffff);
    spotLight.position.set(50, -100, 200);

    spotLight.castShadow = true;
    scene.add(spotLight);

    const animate = function () {
      requestAnimationFrame(animate);
      controls.update();
      blochSphere.rotation.y -= 0.01;

      renderer.render(scene, camera);
    };
    animate();
  }, []);

  return <span />;
};

export default BlochSphere;
